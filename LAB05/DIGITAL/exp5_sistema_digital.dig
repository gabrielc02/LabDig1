<?xml version="1.0" encoding="utf-8"?>
<circuit>
  <version>2</version>
  <attributes/>
  <visualElements>
    <visualElement>
      <elementName>External</elementName>
      <elementAttributes>
        <entry>
          <string>applicationType</string>
          <appType>IVERILOG</appType>
        </entry>
        <entry>
          <string>Label</string>
          <string>circuito_exp5</string>
        </entry>
        <entry>
          <string>externalInputs</string>
          <string>clock,reset,jogar,botoes:4</string>
        </entry>
        <entry>
          <string>Width</string>
          <int>12</int>
        </entry>
        <entry>
          <string>Code</string>
          <string>module circuito_exp5 (
    input clock, 
    input reset, 
    input jogar,
    input [3:0] botoes,
    output pronto, 
    output ganhou, 
    output perdeu,
    output [3:0] leds,
    output db_chavesIgualMemoria,
    output db_enderecoIgualLimite,
	output db_clock,
    output db_tem_jogada,
    output [3:0] db_limite,
    output [3:0] db_contagem,
    output [3:0] db_memoria,
    output [3:0] db_jogada,
    output [3:0] db_estado
);

//Sinais Gerais
wire sig_db_tem_jogada;

//Sinais Intermediario Display
wire [3:0] sig_db_contagem;
wire [3:0] sig_db_memoria;
wire [3:0] sig_db_jogada;
wire [3:0] sig_db_estado;
wire [3:0] sig_db_sequencia;
wire [6:0] hex2_jogada;
wire [6:0] hex0_contagem;
wire [6:0] hex1_memoria;
wire [6:0] hex5_estado;

//Sinais Intermediario UC &amp; FD
//FD - UC
wire sig_fimE;
wire sig_fimS;
wire sig_fimTMR;
wire sig_igualJ;
wire sig_igualS;
wire sig_jogada_feita;

//UC - FD
wire sig_contaE;
wire sig_contaS;
wire sig_contaTMR;
wire sig_limpaM;
wire sig_limpaR;
wire sig_registraM;
wire sig_registraR;
wire sig_zeraE;
wire sig_zeraS;
wire sig_zeraTMR;
wire sig_jogada;

// Fluxo de Dados
exp5_fluxo_dados FD (
    .botoes         ( botoes ),
    .clock          ( clock ),
    .contaE         ( sig_contaE ),
    .contaS         ( sig_contaS ),
    .contaTMR       ( sig_contaTMR ),
    .escreveM       ( 1&apos;h0 ),
    .limpaM         ( sig_limpaM ),
    .limpaR         ( sig_limpaR ),
    .registraM      ( sig_registraM ),
    .registraR      ( sig_registraR ),
    .zeraE          ( sig_zeraE ),
    .zeraS          ( sig_zeraS ),
    .zeraTMR        ( sig_zeraTMR ),
	.db_limite		( db_limite ),
    .db_contagem    ( sig_db_contagem ),
    .db_jogada      ( sig_db_jogada ),
    .db_memoria     ( sig_db_memoria ),
    .db_sequencia   ( sig_db_sequencia ),
    .db_tem_jogada  ( sig_db_tem_jogada ),
    .fimE           ( sig_fimE ),
    .fimS           ( sig_fimS ),
    .fimTMR         ( sig_fimTMR ),
    .igualJ         ( sig_igualJ ),
    .igualS         ( sig_igualS ),
    .jogada_feita   ( sig_jogada_feita ),
    .leds           ( leds )
);

// Unidade de Controle
exp5_unidade_controle UC (
    .clock      ( clock ),
    .fimE       ( sig_fimE ),
    .fimS       ( sig_fimS ),
    .fimTMR     ( sig_fimTMR ),
    .igualJ     ( sig_igualJ ),
    .igualS     ( sig_igualS ),
    .iniciar    ( jogar ),
    .jogada     ( sig_jogada_feita ),
    .reset      ( reset ),
    .contaE     ( sig_contaE ),
    .contaS     ( sig_contaS ),
    .contaTMR   ( sig_contaTMR ),
    .ganhou     ( ganhou ),
    .limpaM     ( sig_limpaM ),
    .limpaR     ( sig_limpaR ),
    .perdeu     ( perdeu ),
    .pronto     ( pronto ),
    .registraM  ( sig_registraM ),
    .registraR  ( sig_registraR ),
    .zeraE      ( sig_zeraE ),
    .zeraS      ( sig_zeraS ),
    .zeraTMR    ( sig_zeraTMR ),
    .db_estado  ( sig_db_estado )
);

// Display 7 segmentos chaves
hexa7seg HEX2 (
    .hexa       ( sig_db_jogada ),
    .display    ( hex2_jogada )
);

// Display 7 segmentos contagem
hexa7seg HEX0 (
    .hexa       ( sig_db_contagem ),
    .display    ( hex0_contagem )
);

// Display 7 segmentos chaves
hexa7seg HEX1 (
    .hexa       ( sig_db_memoria ),
    .display    ( hex1_memoria )
);

// Display 7 estado
hexa7seg HEX5 (
    .hexa       ( sig_db_estado ),
    .display    ( hex5_estado )
);

//Depuracao
assign db_clock                 = clock;
assign db_tem_jogada            = sig_db_tem_jogada;
assign db_jogada                = sig_db_jogada;
assign db_contagem              = sig_db_contagem;
assign db_memoria               = sig_db_memoria;
assign db_chavesIgualMemoria    = sig_igualJ;
assign db_enderecoIgualLimite   = sig_igualS;
assign db_estado                = sig_db_estado;

endmodule

//------------------------------------------------------------------
// Arquivo   : exp5_unidade_controle.v
// Projeto   : Experiencia 5 - Projeto de um Jogo de Sequências de Jogadas
//------------------------------------------------------------------
// Descricao : Unidade de controle
//            
//------------------------------------------------------------------
// Revisoes  :
//     Data        Versao  Autor             Descricao
//     14/01/2024  1.0     Edson Midorikawa  versao inicial
//     25/01/2025  1.2     T1B07             versao atualizada
//     27/01/2025  1.3     T1BB7             nova UC
//------------------------------------------------------------------
//
module exp5_unidade_controle ( //Faltam os sinais fantasmas
    input      clock,
    input      fimE,
    input      fimS,
    input      fimTMR,
    input      igualJ,
    input      igualS,
    input      iniciar,
    input      jogada,
    input      reset,
    output reg contaE,
    output reg contaS,
    output reg contaTMR,
    output reg ganhou,
    output reg limpaM,
    output reg limpaR,
    output reg perdeu,
    output reg pronto,
    output reg registraM,
    output reg registraR,
    output reg zeraE,
    output reg zeraS,
    output reg zeraTMR,
    output reg [3:0] db_estado
);

    // Define estados
    parameter inicial               = 4&apos;h0;  // 0
    parameter inicializa_elementos  = 4&apos;h1;  // 1
    parameter inicia_sequencia      = 4&apos;h2;  // 2
    parameter espera_jogada         = 4&apos;h3;  // 3
    parameter registra_jogada       = 4&apos;h4;  // 4
    parameter compara_jogada        = 4&apos;h5;  // 5
    parameter proxima_jogada        = 4&apos;h6;  // 6
    parameter ultima_sequencia      = 4&apos;h7;  // 7
    parameter proxima_sequencia     = 4&apos;h8;  // 8
    parameter final_errou           = 4&apos;h9;  // 9
    parameter final_acertou         = 4&apos;hA;  // 10
    parameter timeout               = 4&apos;HB;  // 11   
 

    // Variaveis de estado
    reg [3:0] Eatual, Eprox;

    // Memoria de estado
    always @(posedge clock or posedge reset) begin
        if (reset)
            Eatual &lt;= inicial;
        else
            Eatual &lt;= Eprox;
    end

    // Logica de proximo estado
    always @* begin
        case (Eatual)
            inicial:                Eprox = iniciar ? inicializa_elementos : inicial;
            inicializa_elementos:   Eprox = inicia_sequencia;
            inicia_sequencia:       Eprox = espera_jogada;
            espera_jogada:          Eprox = fimTMR ? timeout :  (jogada ? registra_jogada : espera_jogada);
            registra_jogada:        Eprox = compara_jogada;
            compara_jogada:         Eprox = igualJ ? (igualS ? ultima_sequencia : proxima_jogada) : final_errou;
            proxima_jogada:			Eprox = espera_jogada;
            ultima_sequencia:	    Eprox = fimS ? final_acertou : proxima_sequencia;
            proxima_sequencia:      Eprox = inicia_sequencia;
            timeout:                Eprox = iniciar ? inicializa_elementos : timeout;
			final_acertou:          Eprox = iniciar ? inicializa_elementos : final_acertou;
            final_errou:            Eprox = iniciar ? inicializa_elementos : final_errou;
            default:                Eprox = inicial;
        endcase
    end

    // Logica de saida (maquina Moore)
    always @* begin //REVER
        contaE      = (Eatual == proxima_sequencia);
        contaS      = (Eatual == proxima_jogada);
        registraR   = (Eatual == registra_jogada);
        limpaR      = (Eatual == inicial || Eatual == inicializa_elementos);
        zeraE       = (Eatual == inicial || Eatual == inicializa_elementos);
        zeraS       = (Eatual == inicial || Eatual == inicializa_elementos || Eatual == inicia_sequencia);
        zeraTMR     = (Eatual == inicial || Eatual == inicializa_elementos || Eatual == inicia_sequencia || Eatual == proxima_jogada);
        contaTMR    = (Eatual == espera_jogada);
        pronto      = (Eatual == final_acertou || Eatual == final_errou || timeout);
        ganhou      = (Eatual == final_acertou);
        perdeu      = (Eatual == final_errou || Eatual == timeout);

        // Saida de depuracao (estado)
        case (Eatual)
            inicial:                db_estado = 4&apos;h0;  // 0
            inicializa_elementos:   db_estado = 4&apos;h1;  // 1
            inicia_sequencia:       db_estado = 4&apos;h2;  // 2
            espera_jogada:          db_estado = 4&apos;h3;  // 3
            registra_jogada:        db_estado = 4&apos;h4;  // 4
            compara_jogada:         db_estado = 4&apos;h5;  // 5
            proxima_jogada:         db_estado = 4&apos;h6;  // 6
            ultima_sequencia:       db_estado = 4&apos;h7;  // 7
            proxima_sequencia:      db_estado = 4&apos;h8;  // 8
            final_errou:            db_estado = 4&apos;h9;  // 9
            final_acertou:          db_estado = 4&apos;hA;  // 10
            timeout:                db_estado = 4&apos;HB;  // 11  
            default:                db_estado = 4&apos;HF;  // F (erro)
        endcase
    end
	
endmodule
/* --------------------------------------------------------------------
 * Arquivo   : exp4_fluxo_dados.v
 * Projeto   : Experiencia 4 - Desenvolvimento de Projeto de Circuitos Digitais em FPGA
 * --------------------------------------------------------------------
 * Descricao : Fluxo de Dados da Experiencia 4
 * --------------------------------------------------------------------
 * Revisoes  :
 *     Data        Versao  Autor             Descricao
 *     24/01/2025  1.1     Ts1B7  versao inicial
 * --------------------------------------------------------------------
*/

module exp5_fluxo_dados (
    input [3:0] botoes,
    input clock,
    input contaE,
    input contaS,
    input contaTMR,
    input escreveM,
    input limpaM,
    input limpaR,
    input registraM,
    input registraR,
    input zeraE,
    input zeraS,
    input zeraTMR,
    output [3:0] db_contagem,
    output [3:0] db_jogada,
    output [3:0] db_memoria,
    output [3:0] db_sequencia,
	 output [3:0] db_limite,
    output db_tem_jogada,
    output fimE,
    output fimS,
    output fimTMR,
    output igualJ,
    output igualS,
    output jogada_feita,
    output [3:0] leds
);

// Sinais Intermediarios
wire [3:0] sig_mem_address;
wire [3:0] sig_mem_out;
wire [3:0] sig_reg_out;
wire [3:0] sig_contaS_out;
wire sig_db_tem_jogada; 
assign sig_db_tem_jogada = |botoes;

// contador_163 Sequencia
contador_163 contadorSequencia (
    .clock  ( clock ),
    .clr    ( ~zeraS ),
    .ld     ( 1&apos;b1 ),
    .ent    ( 1&apos;b1 ),
    .enp    ( contaS ),
    .D      ( 4&apos;h0 ),
    .Q      ( sig_contaS_out ),
    .rco    ( fimS )
);

// contador_163 Rodada
contador_163 contadorRodada (
    .clock  ( clock ),
    .clr    ( ~zeraE ),
    .ld     ( 1&apos;b1 ),
    .ent    ( 1&apos;b1 ),
    .enp    ( contaE ),
    .D      ( 4&apos;h0 ),
    .Q      ( sig_mem_address ),
    .rco    ( fimE )
);

// contador_timeout
contador_m timeout (
    .clock      ( clock ),
    .conta      ( contaTMR ),
    .zera_as    ( zeraTMR ),
    .zera_s     ( 1&apos;b0 ),
    .Q          ( ),
    .fim        ( fimTMR ),
    .meio       ()

);

// Registrador 4 Bits
registrador_4 reg4Bits (
    .clock   ( clock ),
    .clear   ( limpaR ),
    .enable  ( registraR ),
    .D       ( botoes ),
    .Q       ( sig_reg_out )
);

//Detector de jogadas
edge_detector detector (
    .clock   ( clock ),
    .reset   ( limpaR ),
    .sinal   ( sig_db_tem_jogada ),
    .pulso   ( jogada_feita )
);

// sync_rom_16x4
sync_rom_16x4 memoria (
    .clock      ( clock ),
    .address    ( sig_contaS_out ),
    .data_out   ( sig_mem_out )
);

// comparador_85 Rodada
comparador_85 comparadorRodada (
    .A      ( sig_mem_out ),
    .B      ( sig_reg_out ),
    .ALBi   ( 1&apos;b0 ),
    .AGBi   ( 1&apos;b0 ),
    .AEBi   ( 1&apos;b1 ),
    .ALBo   (  ),
    .AGBo   (  ),
    .AEBo   ( igualJ )
);

// comparador_85 Sequencia
comparador_85 comparadoSequencia (
    .A      ( sig_contaS_out ),
    .B      ( sig_mem_address ),
    .ALBi   ( 1&apos;b0 ),
    .AGBi   ( 1&apos;b0 ),
    .AEBi   ( 1&apos;b1 ),
    .ALBo   (  ),
    .AGBo   (  ), 
    .AEBo   ( igualS )
);

assign db_jogada        = sig_reg_out;
assign db_contagem      = sig_mem_address;
assign db_memoria       = sig_mem_out;
assign db_tem_jogada    = sig_db_tem_jogada;
assign db_limite        = sig_contaS_out;
assign leds             = botoes;
endmodule
/* ------------------------------------------------------------------------
 *  Arquivo   : edge_detector.v
 *  Projeto   : Experiencia 4 - Desenvolvimento de Projeto de
 *                              Circuitos Digitais com FPGA
 * ------------------------------------------------------------------------
 *  Descricao : detector de borda
 *              gera um pulso na saida de 1 periodo de clock
 *              a partir da detecao da borda de subida sa entrada
 * 
 *              sinal de reset ativo em alto
 * 
 *              &gt; codigo adaptado a partir de codigo VHDL disponivel em
 *                https://surf-vhdl.com/how-to-design-a-good-edge-detector/
 * ------------------------------------------------------------------------
 *  Revisoes  :
 *      Data        Versao  Autor             Descricao
 *      26/01/2024  1.0     Edson Midorikawa  versao inicial
 * ------------------------------------------------------------------------
 */
 
module edge_detector (
    input  clock,
    input  reset,
    input  sinal,
    output pulso
);

    reg reg0;
    reg reg1;

    always @(posedge clock or posedge reset) begin
        if (reset) begin
            reg0 &lt;= 1&apos;b0;
            reg1 &lt;= 1&apos;b0;
        end else if (clock) begin
            reg0 &lt;= sinal;
            reg1 &lt;= reg0;
        end
    end

    assign pulso = ~reg1 &amp; reg0;

endmodule


/* -----------------------------------------------------------------
 *  Arquivo   : comparador_85.v
 *  Projeto   : Experiencia 2 - Um Fluxo de Dados Simples
 * -----------------------------------------------------------------
 * Descricao : comparador de magnitude de 4 bits 
 *             similar ao CI 7485
 *             baseado em descricao comportamental disponivel em	
 * https://web.eecs.umich.edu/~jhayes/iscas.restore/74L85b.v
 * -----------------------------------------------------------------
 * Revisoes  :
 *     Data        Versao  Autor             Descricao
 *     21/12/2023  1.0     Edson Midorikawa  criacao
 * -----------------------------------------------------------------
 */

module comparador_85 (ALBi, AGBi, AEBi, A, B, ALBo, AGBo, AEBo);

    input[3:0] A, B;
    input      ALBi, AGBi, AEBi;
    output     ALBo, AGBo, AEBo;
    wire[4:0]  CSL, CSG;

    assign CSL  = ~A + B + ALBi;
    assign ALBo = ~CSL[4];
    assign CSG  = A + ~B + AGBi;
    assign AGBo = ~CSG[4];
    assign AEBo = ((A == B) &amp;&amp; AEBi);

endmodule /* comparador_85 */

//------------------------------------------------------------------
// Arquivo   : contador_163.v
// Projeto   : Experiencia 3 - Unidade de Controle
//------------------------------------------------------------------
// Descricao : Contador binario de 4 bits, modulo 16
//             similar ao componente 74163
//
// baseado no componente Vrcntr4u.v do livro Digital Design Principles 
// and Practices, Fifth Edition, by John F. Wakerly              
//------------------------------------------------------------------
// Revisoes  :
//     Data        Versao  Autor             Descricao
//     17/01/2025  1.0     Grupo T1B07  versao inicial
//------------------------------------------------------------------
//
module contador_163 ( clock, clr, ld, ent, enp, D, Q, rco );
    input clock, clr, ld, ent, enp;
    input [3:0] D;
    output reg [3:0] Q;
    output reg rco;

    always @ (posedge clock)
        if (~clr)               Q &lt;= 4&apos;d0;
        else if (~ld)           Q &lt;= D;
        else if (ent &amp;&amp; enp)    Q &lt;= Q + 1&apos;b1;
        else                    Q &lt;= Q;
 
    always @ (Q or ent)
        if (ent &amp;&amp; (Q == 4&apos;d15))   rco = 1;
        else                       rco = 0;
endmodule

/* ----------------------------------------------------------------
 * Arquivo   : hexa7seg.v
 * Projeto   : Experiencia 2 - Um Fluxo de Dados Simples
 *--------------------------------------------------------------
 * Descricao : decodificador hexadecimal para 
 *             display de 7 segmentos 
 * 
 * entrada : hexa - codigo binario de 4 bits hexadecimal
 * saida   : sseg - codigo de 7 bits para display de 7 segmentos
 *
 * baseado no componente bcd7seg.v da Intel FPGA
 *--------------------------------------------------------------
 * dica de uso: mapeamento para displays da placa DE0-CV
 *              bit 6 mais significativo é o bit a esquerda
 *              p.ex. sseg(6) -&gt; HEX0[6] ou HEX06
 *--------------------------------------------------------------
 * Revisoes  :
 *     Data        Versao  Autor             Descricao
 *     24/12/2023  1.0     Edson Midorikawa  criacao
 *--------------------------------------------------------------
 */

module hexa7seg (hexa, display);
    input      [3:0] hexa;
    output reg [6:0] display;

    /*
     *    ---
     *   | 0 |
     * 5 |   | 1
     *   |   |
     *    ---
     *   | 6 |
     * 4 |   | 2
     *   |   |
     *    ---
     *     3
     */
        
    always @(hexa)
    case (hexa)
        4&apos;h0:    display = 7&apos;b1000000;
        4&apos;h1:    display = 7&apos;b1111001;
        4&apos;h2:    display = 7&apos;b0100100;
        4&apos;h3:    display = 7&apos;b0110000;
        4&apos;h4:    display = 7&apos;b0011001;
        4&apos;h5:    display = 7&apos;b0010010;
        4&apos;h6:    display = 7&apos;b0000010;
        4&apos;h7:    display = 7&apos;b1111000;
        4&apos;h8:    display = 7&apos;b0000000;
        4&apos;h9:    display = 7&apos;b0010000;
        4&apos;ha:    display = 7&apos;b0001000;
        4&apos;hb:    display = 7&apos;b0000011;
        4&apos;hc:    display = 7&apos;b1000110;
        4&apos;hd:    display = 7&apos;b0100001;
        4&apos;he:    display = 7&apos;b0000110;
        4&apos;hf:    display = 7&apos;b0001110;
        default: display = 7&apos;b1111111;
    endcase
endmodule

//------------------------------------------------------------------
// Arquivo   : registrador_4.v
// Projeto   : Experiencia 3 - Projeto de uma Unidade de Controle 
//------------------------------------------------------------------
// Descricao : Registrador de 4 bits
//             
//------------------------------------------------------------------
// Revisoes  :
//     Data        Versao  Autor             Descricao
//     14/12/2023  1.0     Edson Midorikawa  versao inicial
//------------------------------------------------------------------
//
module registrador_4 (
    input        clock,
    input        clear,
    input        enable,
    input  [3:0] D,
    output [3:0] Q
);

    reg [3:0] IQ;

    always @(posedge clock or posedge clear) begin
        if (clear)
            IQ &lt;= 0;
        else if (enable)
            IQ &lt;= D;
    end

    assign Q = IQ;

endmodule

//------------------------------------------------------------------
// Arquivo   : sync_rom_16x4.v
// Projeto   : Experiencia 3 - Projeto de uma Unidade de Controle 
//------------------------------------------------------------------
// Descricao : ROM sincrona 16x4 (conteúdo pre-programado)
//             
//------------------------------------------------------------------
// Revisoes  :
//     Data        Versao  Autor             Descricao
//     14/12/2023  1.0     Edson Midorikawa  versao inicial
//------------------------------------------------------------------
//
module sync_rom_16x4 (clock, address, data_out);
    input            clock;
    input      [3:0] address;
    output reg [3:0] data_out;

    always @ (posedge clock)
    begin
        case (address)
            4&apos;b0000: data_out = 4&apos;b0001;
            4&apos;b0001: data_out = 4&apos;b0010;
            4&apos;b0010: data_out = 4&apos;b0100;
            4&apos;b0011: data_out = 4&apos;b1000;
            4&apos;b0100: data_out = 4&apos;b0100;
            4&apos;b0101: data_out = 4&apos;b0010;
            4&apos;b0110: data_out = 4&apos;b0001;
            4&apos;b0111: data_out = 4&apos;b0001;
            4&apos;b1000: data_out = 4&apos;b0010;
            4&apos;b1001: data_out = 4&apos;b0010;
            4&apos;b1010: data_out = 4&apos;b0100;
            4&apos;b1011: data_out = 4&apos;b0100;
            4&apos;b1100: data_out = 4&apos;b1000;
            4&apos;b1101: data_out = 4&apos;b1000;
            4&apos;b1110: data_out = 4&apos;b0001;
            4&apos;b1111: data_out = 4&apos;b0100;
        endcase
    end
endmodule


/*---------------Laboratorio Digital-------------------------------------
 * Arquivo   : contador_m.v
 * Projeto   : Experiencia 4 - Desenvolvimento de Projeto de 
 *                             Circuitos Digitais em FPGA
 *-----------------------------------------------------------------------
 * Descricao : contador binario, modulo m, com parametros 
 *             M (modulo do contador) e N (numero de bits),
 *             sinais para clear assincrono (zera_as) e sincrono (zera_s)
 *             e saidas de fim e meio de contagem
 *             
 *-----------------------------------------------------------------------
 * Revisoes  :
 *     Data        Versao  Autor             Descricao
 *     30/01/2024  1.0     Edson Midorikawa  criacao
 *     16/01/2025  1.1     Edson Midorikawa  revisao
 *-----------------------------------------------------------------------
 */

module contador_m #(parameter M=3000, N=12)
  (
   input  wire          clock,
   input  wire          zera_as,
   input  wire          zera_s,
   input  wire          conta,
   output reg  [N-1:0]  Q,
   output reg           fim,
   output reg           meio
  );

  always @(posedge clock or posedge zera_as) begin
    if (zera_as) begin
      Q &lt;= 0;
    end else if (clock) begin
      if (zera_s) begin
        Q &lt;= 0;
      end else if (conta) begin
        if (Q == M-1) begin
          Q &lt;= 0;
        end else begin
          Q &lt;= Q + 1&apos;b1;
        end
      end
    end
  end

  // Saidas
  always @ (Q)
      if (Q == M-1)   fim = 1;
      else            fim = 0;

  always @ (Q)
      if (Q == M/2-1) meio = 1;
      else            meio = 0;

endmodule</string>
        </entry>
        <entry>
          <string>externalOutputs</string>
          <string>pronto,ganhou,perdeu,leds:4,db_chavesIgualMemoria,db_enderecoIgualLimite,db_clock,db_tem_jogada,db_limite:4,db_contagem:4,db_memoria:4,db_jogada:4,db_estado:4</string>
        </entry>
      </elementAttributes>
      <pos x="320" y="180"/>
    </visualElement>
    <visualElement>
      <elementName>Clock</elementName>
      <elementAttributes>
        <entry>
          <string>runRealTime</string>
          <boolean>true</boolean>
        </entry>
      </elementAttributes>
      <pos x="100" y="180"/>
    </visualElement>
    <visualElement>
      <elementName>Out</elementName>
      <elementAttributes/>
      <pos x="680" y="180"/>
    </visualElement>
    <visualElement>
      <elementName>Out</elementName>
      <elementAttributes/>
      <pos x="720" y="200"/>
    </visualElement>
    <visualElement>
      <elementName>Out</elementName>
      <elementAttributes/>
      <pos x="760" y="220"/>
    </visualElement>
    <visualElement>
      <elementName>Out</elementName>
      <elementAttributes>
        <entry>
          <string>Bits</string>
          <int>4</int>
        </entry>
      </elementAttributes>
      <pos x="820" y="240"/>
    </visualElement>
    <visualElement>
      <elementName>Out</elementName>
      <elementAttributes/>
      <pos x="720" y="260"/>
    </visualElement>
    <visualElement>
      <elementName>Out</elementName>
      <elementAttributes/>
      <pos x="760" y="280"/>
    </visualElement>
    <visualElement>
      <elementName>Out</elementName>
      <elementAttributes/>
      <pos x="680" y="300"/>
    </visualElement>
    <visualElement>
      <elementName>Out</elementName>
      <elementAttributes>
        <entry>
          <string>addValueToGraph</string>
          <boolean>false</boolean>
        </entry>
        <entry>
          <string>intFormat</string>
          <intFormat>bin</intFormat>
        </entry>
      </elementAttributes>
      <pos x="820" y="320"/>
    </visualElement>
    <visualElement>
      <elementName>In</elementName>
      <elementAttributes>
        <entry>
          <string>Bits</string>
          <int>4</int>
        </entry>
        <entry>
          <string>intFormat</string>
          <intFormat>bin</intFormat>
        </entry>
      </elementAttributes>
      <pos x="100" y="340"/>
    </visualElement>
    <visualElement>
      <elementName>Seven-Seg-Hex</elementName>
      <elementAttributes/>
      <pos x="900" y="120"/>
    </visualElement>
    <visualElement>
      <elementName>Seven-Seg-Hex</elementName>
      <elementAttributes/>
      <pos x="1020" y="120"/>
    </visualElement>
    <visualElement>
      <elementName>Seven-Seg-Hex</elementName>
      <elementAttributes/>
      <pos x="1160" y="120"/>
    </visualElement>
    <visualElement>
      <elementName>Seven-Seg-Hex</elementName>
      <elementAttributes/>
      <pos x="1240" y="120"/>
    </visualElement>
    <visualElement>
      <elementName>Ground</elementName>
      <elementAttributes/>
      <pos x="1300" y="440"/>
    </visualElement>
    <visualElement>
      <elementName>Button</elementName>
      <elementAttributes/>
      <pos x="100" y="220"/>
    </visualElement>
    <visualElement>
      <elementName>Button</elementName>
      <elementAttributes/>
      <pos x="100" y="260"/>
    </visualElement>
    <visualElement>
      <elementName>Out</elementName>
      <elementAttributes>
        <entry>
          <string>addValueToGraph</string>
          <boolean>false</boolean>
        </entry>
        <entry>
          <string>Bits</string>
          <int>4</int>
        </entry>
        <entry>
          <string>intFormat</string>
          <intFormat>bin</intFormat>
        </entry>
      </elementAttributes>
      <pos x="600" y="340"/>
    </visualElement>
  </visualElements>
  <wires>
    <wire>
      <p1 x="560" y="320"/>
      <p2 x="820" y="320"/>
    </wire>
    <wire>
      <p1 x="1220" y="320"/>
      <p2 x="1300" y="320"/>
    </wire>
    <wire>
      <p1 x="560" y="260"/>
      <p2 x="720" y="260"/>
    </wire>
    <wire>
      <p1 x="100" y="260"/>
      <p2 x="140" y="260"/>
    </wire>
    <wire>
      <p1 x="560" y="420"/>
      <p2 x="940" y="420"/>
    </wire>
    <wire>
      <p1 x="560" y="200"/>
      <p2 x="720" y="200"/>
    </wire>
    <wire>
      <p1 x="120" y="200"/>
      <p2 x="320" y="200"/>
    </wire>
    <wire>
      <p1 x="560" y="360"/>
      <p2 x="1060" y="360"/>
    </wire>
    <wire>
      <p1 x="560" y="300"/>
      <p2 x="680" y="300"/>
    </wire>
    <wire>
      <p1 x="960" y="300"/>
      <p2 x="1080" y="300"/>
    </wire>
    <wire>
      <p1 x="1080" y="300"/>
      <p2 x="1220" y="300"/>
    </wire>
    <wire>
      <p1 x="560" y="240"/>
      <p2 x="820" y="240"/>
    </wire>
    <wire>
      <p1 x="160" y="240"/>
      <p2 x="320" y="240"/>
    </wire>
    <wire>
      <p1 x="560" y="400"/>
      <p2 x="1280" y="400"/>
    </wire>
    <wire>
      <p1 x="100" y="180"/>
      <p2 x="320" y="180"/>
    </wire>
    <wire>
      <p1 x="560" y="180"/>
      <p2 x="680" y="180"/>
    </wire>
    <wire>
      <p1 x="100" y="340"/>
      <p2 x="160" y="340"/>
    </wire>
    <wire>
      <p1 x="560" y="340"/>
      <p2 x="600" y="340"/>
    </wire>
    <wire>
      <p1 x="560" y="280"/>
      <p2 x="760" y="280"/>
    </wire>
    <wire>
      <p1 x="560" y="220"/>
      <p2 x="760" y="220"/>
    </wire>
    <wire>
      <p1 x="100" y="220"/>
      <p2 x="120" y="220"/>
    </wire>
    <wire>
      <p1 x="140" y="220"/>
      <p2 x="320" y="220"/>
    </wire>
    <wire>
      <p1 x="560" y="380"/>
      <p2 x="1200" y="380"/>
    </wire>
    <wire>
      <p1 x="160" y="240"/>
      <p2 x="160" y="340"/>
    </wire>
    <wire>
      <p1 x="1280" y="260"/>
      <p2 x="1280" y="400"/>
    </wire>
    <wire>
      <p1 x="960" y="260"/>
      <p2 x="960" y="300"/>
    </wire>
    <wire>
      <p1 x="1200" y="260"/>
      <p2 x="1200" y="380"/>
    </wire>
    <wire>
      <p1 x="1060" y="260"/>
      <p2 x="1060" y="360"/>
    </wire>
    <wire>
      <p1 x="1300" y="260"/>
      <p2 x="1300" y="320"/>
    </wire>
    <wire>
      <p1 x="1300" y="320"/>
      <p2 x="1300" y="440"/>
    </wire>
    <wire>
      <p1 x="1220" y="260"/>
      <p2 x="1220" y="300"/>
    </wire>
    <wire>
      <p1 x="1220" y="300"/>
      <p2 x="1220" y="320"/>
    </wire>
    <wire>
      <p1 x="120" y="200"/>
      <p2 x="120" y="220"/>
    </wire>
    <wire>
      <p1 x="1080" y="260"/>
      <p2 x="1080" y="300"/>
    </wire>
    <wire>
      <p1 x="140" y="220"/>
      <p2 x="140" y="260"/>
    </wire>
    <wire>
      <p1 x="940" y="260"/>
      <p2 x="940" y="420"/>
    </wire>
  </wires>
  <measurementOrdering/>
</circuit>